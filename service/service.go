package service

import (
	"github.com/mbarreca/gosix/api"
	"github.com/mbarreca/gosix/client"
	"github.com/mbarreca/gosix/consumer"
	"github.com/mbarreca/gosix/library"
	"github.com/mbarreca/gosix/models"
)

type Service struct {
	client *client.Client
	c      *consumer.Consumer
}

// Constructor - You *shouldn't* be using this
func New(c *client.Client, consumer *consumer.Consumer) *Service {
	return &Service{client: c, c: consumer}
}

// Gets the Service attached to an ID
// id -> A specific Service to get
func (s *Service) Get(id string) (models.Service, error) {
	resp, err := api.API[models.Service, models.Get](id, "", models.Service{}, s.client)
	if err != nil {
		return models.Service{}, err
	}
	return *resp.(models.Object[models.Service]).Value, nil
}

// Get all services
func (s *Service) GetAll() ([]models.Service, error) {
	resp, err := api.API[models.Service, models.Get]("", "", models.Service{}, s.client)
	if err != nil {
		return nil, err
	}
	var ret []models.Service
	credentials := resp.(models.All[models.Service])
	for _, credential := range *credentials.Objects {
		ret = append(ret, *credential.Value)
	}
	return ret, nil
}

// Create a service, leave the ID blank for an autogenerated ID
// id -> A specific Service to get
// service -> Service Object
func (s *Service) Create(id string, service models.Service) error {
	_, err := api.API[models.Service, models.Create](id, "", service, s.client)
	if err != nil {
		return err
	}
	return nil
}

// Update a Service
// id -> A specific Service to get
// service -> Service Object
func (s *Service) Update(id string, service models.Service) error {
	_, err := api.API[models.Service, models.Update](id, "", service, s.client)
	if err != nil {
		return err
	}
	return nil
}

// Delete a Service
// id -> A specific Service to get
func (s *Service) Delete(id string) error {
	_, err := api.API[models.Service, models.Delete](id, "", models.Service{}, s.client)
	if err != nil {
		return err
	}
	return nil
}

/*
	Plugin Specific Functions
*/

// This will get the plugin attached to a consumer and write it into plugin
// id -> The id of the consumer
// plugin -> The plugin object (used only for type)
func (s *Service) GetPlugin(id string, plugin any) (any, error) {
	value, err := s.Get(id)
	if err != nil {
		return nil, err
	}
	return library.GetPlugin(value.Plugins, plugin)
}

// This will add the plugin if it doesn't exist or update it if it does
// id -> The id of the route
// plugin -> The plugin object
func (s *Service) AddPlugin(id string, plugin any) error {
	value, err := s.Get(id)
	if err != nil {
		return err
	}
	p, err := library.AddPlugin(value.Plugins, plugin)
	if err != nil {
		return err
	}
	value.Plugins = p
	if err := s.Update(value.ID, value); err != nil {
		return err
	}
	return nil
}

// This will delete the plugin if it exists, if it doesn't it will still return no error
// id -> The id of the consumer
// plugin -> The plugin object (used only for type)
func (s *Service) DeletePlugin(id string, plugin any) error {
	value, err := s.Get(id)
	if err != nil {
		return err
	}
	p, err := library.DeletePlugin(value.Plugins, plugin)
	if err != nil {
		return err
	}
	value.Plugins = p
	if err := s.Update(value.ID, value); err != nil {
		return err
	}
	return nil
}
